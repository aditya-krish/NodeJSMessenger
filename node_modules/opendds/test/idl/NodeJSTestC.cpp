// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p19
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "NodeJSTestC.h"
#include "tao/CDR.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "NodeJSTestC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:108

#if !defined (_MOD_MYSEQ_CS_)
#define _MOD_MYSEQ_CS_

Mod::MySeq::MySeq (void)
{}

Mod::MySeq::MySeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Short
      > (max)
{}

Mod::MySeq::MySeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Short * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Short
      >
    (max, length, buffer, release)
{}

Mod::MySeq::~MySeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:108

#if !defined (_MOD_NESTEDSEQ_CS_)
#define _MOD_NESTEDSEQ_CS_

Mod::NestedSeq::NestedSeq (void)
{}

Mod::NestedSeq::NestedSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        CORBA::StringSeq
      > (max)
{}

Mod::NestedSeq::NestedSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    CORBA::StringSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        CORBA::StringSeq
      >
    (max, length, buffer, release)
{}

Mod::NestedSeq::~NestedSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

Mod::MyUnion::MyUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (Mod::MyEnum) -1;
}

Mod::MyUnion::MyUnion (const ::Mod::MyUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Mod::one:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case Mod::two:
    {
      this->u_.b_ = u.u_.b_;
    }
    break;
    case Mod::three:
    {
      this->u_.d_ = u.u_.d_;
    }
    break;
    case Mod::four:
    {
      if (u.u_.s_ == 0)
        {
          this->u_.s_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.s_,
              Mod::NestedSeq (*u.u_.s_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Mod::MyUnion::~MyUnion (void)
{
  // Finalize.
  this->_reset ();
}

Mod::MyUnion &
Mod::MyUnion::operator= (const ::Mod::MyUnion &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Mod::one:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case Mod::two:
    {
      this->u_.b_ = u.u_.b_;
    }
    break;
    case Mod::three:
    {
      this->u_.d_ = u.u_.d_;
    }
    break;
    case Mod::four:
    {
      if (u.u_.s_ == 0)
        {
          this->u_.s_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.s_,
              Mod::NestedSeq (*u.u_.s_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Mod::MyUnion::_reset (void)
{
  switch (this->disc_)
  {
    
    case Mod::one:
      
    break;
    
    case Mod::two:
      
    break;
    
    case Mod::three:
      
    break;
    
    case Mod::four:
      delete this->u_.s_;
      this->u_.s_ = 0;
      
    break;
    
    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:108

#if !defined (_MOD_NESTEDNESTEDSEQ_CS_)
#define _MOD_NESTEDNESTEDSEQ_CS_

Mod::NestedNestedSeq::NestedNestedSeq (void)
{}

Mod::NestedNestedSeq::NestedNestedSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NestedSeq
      > (max)
{}

Mod::NestedNestedSeq::NestedNestedSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Mod::NestedSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NestedSeq
      >
    (max, length, buffer, release)
{}

Mod::NestedNestedSeq::~NestedNestedSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:108

#if !defined (_MOD_NESTEDNESTEDNESTEDSEQ_CS_)
#define _MOD_NESTEDNESTEDNESTEDSEQ_CS_

Mod::NestedNestedNestedSeq::NestedNestedNestedSeq (void)
{}

Mod::NestedNestedNestedSeq::NestedNestedNestedSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NestedNestedSeq
      > (max)
{}

Mod::NestedNestedNestedSeq::NestedNestedNestedSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Mod::NestedNestedSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NestedNestedSeq
      >
    (max, length, buffer, release)
{}

Mod::NestedNestedNestedSeq::~NestedNestedNestedSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Mod::CharArray_slice *
Mod::CharArray_dup (const Mod::CharArray_slice *_tao_src_array)
{
  Mod::CharArray_slice *_tao_dup_array =
    Mod::CharArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Mod::CharArray_slice *> (0);
    }
  
  Mod::CharArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Mod::CharArray_slice *
Mod::CharArray_alloc (void)
{
  Mod::CharArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Char[6], 0);
  return retval;
}

void
Mod::CharArray_free (
    Mod::CharArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Mod::CharArray_copy (
    Mod::CharArray_slice * _tao_to,
    const Mod::CharArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 6; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Mod::StringArray_slice *
Mod::StringArray_dup (const Mod::StringArray_slice *_tao_src_array)
{
  Mod::StringArray_slice *_tao_dup_array =
    Mod::StringArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Mod::StringArray_slice *> (0);
    }
  
  Mod::StringArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Mod::StringArray_slice *
Mod::StringArray_alloc (void)
{
  Mod::StringArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO::String_Manager[4], 0);
  return retval;
}

void
Mod::StringArray_free (
    Mod::StringArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Mod::StringArray_copy (
    Mod::StringArray_slice * _tao_to,
    const Mod::StringArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:108

#if !defined (_MOD_MYUNIONSEQ_CS_)
#define _MOD_MYUNIONSEQ_CS_

Mod::MyUnionSeq::MyUnionSeq (void)
{}

Mod::MyUnionSeq::MyUnionSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        MyUnion
      > (max)
{}

Mod::MyUnionSeq::MyUnionSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Mod::MyUnion * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        MyUnion
      >
    (max, length, buffer, release)
{}

Mod::MyUnionSeq::~MyUnionSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

Mod::MyOtherUnion::MyOtherUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (Mod::MyOtherEnum) -1;
}

Mod::MyOtherUnion::MyOtherUnion (const ::Mod::MyOtherUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Mod::small:
    {
      this->u_.one_ = ::CORBA::string_dup (u.u_.one_);
    }
    break;
    case Mod::medium:
    {
      if (u.u_.two_ == 0)
        {
          this->u_.two_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.two_,
              Mod::NestedSeq (*u.u_.two_)
            );
        }
    }
    break;
    case Mod::large:
    {
      if (u.u_.three_ == 0)
        {
          this->u_.three_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.three_,
              Mod::Sample (*u.u_.three_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Mod::MyOtherUnion::~MyOtherUnion (void)
{
  // Finalize.
  this->_reset ();
}

Mod::MyOtherUnion &
Mod::MyOtherUnion::operator= (const ::Mod::MyOtherUnion &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Mod::small:
    {
      this->u_.one_ = ::CORBA::string_dup (u.u_.one_);
    }
    break;
    case Mod::medium:
    {
      if (u.u_.two_ == 0)
        {
          this->u_.two_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.two_,
              Mod::NestedSeq (*u.u_.two_),
              *this
            );
        }
    }
    break;
    case Mod::large:
    {
      if (u.u_.three_ == 0)
        {
          this->u_.three_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.three_,
              Mod::Sample (*u.u_.three_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Mod::MyOtherUnion::_reset (void)
{
  switch (this->disc_)
  {
    
    case Mod::small:
      ::CORBA::string_free (this->u_.one_);
      this->u_.one_ = 0;
      
    break;
    
    case Mod::medium:
      delete this->u_.two_;
      this->u_.two_ = 0;
      
    break;
    
    case Mod::large:
      delete this->u_.three_;
      this->u_.three_ = 0;
      
    break;
    
    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Mod::JunkType_slice *
Mod::JunkType_dup (const Mod::JunkType_slice *_tao_src_array)
{
  Mod::JunkType_slice *_tao_dup_array =
    Mod::JunkType_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Mod::JunkType_slice *> (0);
    }
  
  Mod::JunkType_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Mod::JunkType_slice *
Mod::JunkType_alloc (void)
{
  Mod::JunkType_slice *retval = 0;
  ACE_NEW_RETURN (retval, Mod::MyOtherUnion[2], 0);
  return retval;
}

void
Mod::JunkType_free (
    Mod::JunkType_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Mod::JunkType_copy (
    Mod::JunkType_slice * _tao_to,
    const Mod::JunkType_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 2; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

Mod::MaskType_slice *
Mod::MaskType_dup (const Mod::MaskType_slice *_tao_src_array)
{
  Mod::MaskType_slice *_tao_dup_array =
    Mod::MaskType_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Mod::MaskType_slice *> (0);
    }
  
  Mod::MaskType_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Mod::MaskType_slice *
Mod::MaskType_alloc (void)
{
  Mod::MaskType_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Boolean[2], 0);
  return retval;
}

void
Mod::MaskType_free (
    Mod::MaskType_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
Mod::MaskType_copy (
    Mod::MaskType_slice * _tao_to,
    const Mod::MaskType_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 2; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Mod::MyEnum _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Mod::MyEnum & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Mod::MyEnum> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::BasicTypes &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.o)) &&
    (strm << _tao_aggregate.us) &&
    (strm << _tao_aggregate.s) &&
    (strm << _tao_aggregate.ul) &&
    (strm << _tao_aggregate.l) &&
    (strm << _tao_aggregate.ull) &&
    (strm << _tao_aggregate.ll) &&
    (strm << _tao_aggregate.f) &&
    (strm << _tao_aggregate.d) &&
    (strm << _tao_aggregate.ld) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.b)) &&
    (strm << ::ACE_OutputCDR::from_char (_tao_aggregate.c)) &&
    (strm << _tao_aggregate.str.in ()) &&
    (strm << _tao_aggregate.wstr.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::BasicTypes &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.o)) &&
    (strm >> _tao_aggregate.us) &&
    (strm >> _tao_aggregate.s) &&
    (strm >> _tao_aggregate.ul) &&
    (strm >> _tao_aggregate.l) &&
    (strm >> _tao_aggregate.ull) &&
    (strm >> _tao_aggregate.ll) &&
    (strm >> _tao_aggregate.f) &&
    (strm >> _tao_aggregate.d) &&
    (strm >> _tao_aggregate.ld) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.b)) &&
    (strm >> ::ACE_InputCDR::to_char (_tao_aggregate.c)) &&
    (strm >> _tao_aggregate.str.out ()) &&
    (strm >> _tao_aggregate.wstr.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Mod_MySeq_CPP_
#define _TAO_CDR_OP_Mod_MySeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MySeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MySeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Mod_MySeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Mod_NestedSeq_CPP_
#define _TAO_CDR_OP_Mod_NestedSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::NestedSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::NestedSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Mod_NestedSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MyUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Mod::one:
      {
        result = strm << _tao_union.a ();
      }
      break;
    case Mod::two:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.b ());
      }
      break;
    case Mod::three:
      {
        result = strm << _tao_union.d ();
      }
      break;
    case Mod::four:
      {
        result = strm << _tao_union.s ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MyUnion &_tao_union
  )
{
  Mod::MyEnum _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Mod::one:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Mod::two:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.b (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Mod::three:
      {
        CORBA::Double _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.d (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Mod::four:
      {
        Mod::NestedSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.s (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Mod_NestedNestedSeq_CPP_
#define _TAO_CDR_OP_Mod_NestedNestedSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::NestedNestedSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::NestedNestedSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Mod_NestedNestedSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Mod_NestedNestedNestedSeq_CPP_
#define _TAO_CDR_OP_Mod_NestedNestedNestedSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::NestedNestedNestedSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::NestedNestedNestedSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Mod_NestedNestedNestedSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::CharArray_forany &_tao_array)
{
  return
    strm.write_char_array (
        reinterpret_cast <const ACE_CDR::Char *> (_tao_array.in ()),
        6);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::CharArray_forany &_tao_array)
{
  return
    strm.read_char_array (
        reinterpret_cast <ACE_CDR::Char *> (_tao_array.out ()),
        6);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::StringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::StringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::Sample &_tao_aggregate)
{
  Mod::CharArray_forany _tao_aggregate_ca
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::CharArray_slice*) (
      #else
      (const_cast<
          Mod::CharArray_slice*> (
      #endif
          _tao_aggregate.ca
        )
    );
  Mod::StringArray_forany _tao_aggregate_sa
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::StringArray_slice*) (
      #else
      (const_cast<
          Mod::StringArray_slice*> (
      #endif
          _tao_aggregate.sa
        )
    );
  return
    (strm << _tao_aggregate.id) &&
    (strm << _tao_aggregate.data.in ()) &&
    (strm << _tao_aggregate.enu) &&
    (strm << _tao_aggregate.enu2) &&
    (strm << _tao_aggregate.bt) &&
    (strm << _tao_aggregate.seq1) &&
    (strm << _tao_aggregate.seq2) &&
    (strm << _tao_aggregate.ns) &&
    (strm << _tao_aggregate.mu) &&
    (strm << _tao_aggregate_ca) &&
    (strm << _tao_aggregate_sa);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::Sample &_tao_aggregate)
{
  Mod::CharArray_forany _tao_aggregate_ca
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::CharArray_slice*) (
      #else
      (const_cast<
          Mod::CharArray_slice*> (
      #endif
          _tao_aggregate.ca
        )
    );
  Mod::StringArray_forany _tao_aggregate_sa
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::StringArray_slice*) (
      #else
      (const_cast<
          Mod::StringArray_slice*> (
      #endif
          _tao_aggregate.sa
        )
    );
  return
    (strm >> _tao_aggregate.id) &&
    (strm >> _tao_aggregate.data.out ()) &&
    (strm >> _tao_aggregate.enu) &&
    (strm >> _tao_aggregate.enu2) &&
    (strm >> _tao_aggregate.bt) &&
    (strm >> _tao_aggregate.seq1) &&
    (strm >> _tao_aggregate.seq2) &&
    (strm >> _tao_aggregate.ns) &&
    (strm >> _tao_aggregate.mu) &&
    (strm >> _tao_aggregate_ca) &&
    (strm >> _tao_aggregate_sa);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Mod_MyUnionSeq_CPP_
#define _TAO_CDR_OP_Mod_MyUnionSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MyUnionSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MyUnionSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Mod_MyUnionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Mod::MyOtherEnum _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Mod::MyOtherEnum & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Mod::MyOtherEnum> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MyOtherUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Mod::small:
      {
        result = strm << _tao_union.one ();
      }
      break;
    case Mod::medium:
      {
        result = strm << _tao_union.two ();
      }
      break;
    case Mod::large:
      {
        result = strm << _tao_union.three ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MyOtherUnion &_tao_union
  )
{
  Mod::MyOtherEnum _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Mod::small:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();

        if (result)
          {
            _tao_union.one (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Mod::medium:
      {
        Mod::NestedSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.two (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Mod::large:
      {
        Mod::Sample _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.three (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::JunkType_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 2 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::JunkType_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 2 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MaskType_forany &_tao_array)
{
  return
    strm.write_boolean_array (
        reinterpret_cast <const ACE_CDR::Boolean *> (_tao_array.in ()),
        2);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MaskType_forany &_tao_array)
{
  return
    strm.read_boolean_array (
        reinterpret_cast <ACE_CDR::Boolean *> (_tao_array.out ()),
        2);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Mod::MaskedJunk &_tao_aggregate)
{
  Mod::JunkType_forany _tao_aggregate_junk
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::JunkType_slice*) (
      #else
      (const_cast<
          Mod::JunkType_slice*> (
      #endif
          _tao_aggregate.junk
        )
    );
  Mod::MaskType_forany _tao_aggregate_mask
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::MaskType_slice*) (
      #else
      (const_cast<
          Mod::MaskType_slice*> (
      #endif
          _tao_aggregate.mask
        )
    );
  return
    (strm << _tao_aggregate_junk) &&
    (strm << _tao_aggregate_mask);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Mod::MaskedJunk &_tao_aggregate)
{
  Mod::JunkType_forany _tao_aggregate_junk
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::JunkType_slice*) (
      #else
      (const_cast<
          Mod::JunkType_slice*> (
      #endif
          _tao_aggregate.junk
        )
    );
  Mod::MaskType_forany _tao_aggregate_mask
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((Mod::MaskType_slice*) (
      #else
      (const_cast<
          Mod::MaskType_slice*> (
      #endif
          _tao_aggregate.mask
        )
    );
  return
    (strm >> _tao_aggregate_junk) &&
    (strm >> _tao_aggregate_mask);
}

TAO_END_VERSIONED_NAMESPACE_DECL



