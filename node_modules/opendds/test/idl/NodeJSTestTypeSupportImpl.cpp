/* Generated by /home/agilehealth_ai/DDS/OpenDDS-3.14.1/bin/opendds_idl version 3.14.1 (ACE version 6.2a_p19) running on input file NodeJSTest.idl */
#include "NodeJSTestTypeSupportImpl.h"

#include <cstring>
#include <nan.h>
#include <sstream>
#include <stdexcept>
#include "dds/CorbaSeq/ShortSeqTypeSupportImpl.h"
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/DataReaderImpl_T.h"
#include "dds/DCPS/DataWriterImpl_T.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/V8TypeConverter.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/CorbaSeq/StringSeqTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: ShortSeq */


/* End TYPEDEF: ShortSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: Mod */



/* Begin ENUM: MyEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const Mod::MyEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, Mod::MyEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<Mod::MyEnum>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_Mod_MyEnum_names[] = {
  "one",
  "two",
  "three",
  "four"
};
const size_t gen_Mod_MyEnum_names_size = 4;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: MyEnum */


/* Begin STRUCT: BasicTypes */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::BasicTypes& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.o));
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.us);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.s);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.ul);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.l);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.ull);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.ll);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.f);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(stru.d);
  if ((size + padding) % 8) {
    padding += 8 - ((size + padding) % 8);
  }
  size += gen_max_marshaled_size(ACE_CDR::LongDouble());
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.b));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_char(stru.c));
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.str.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.wstr.in()) * OpenDDS::DCPS::Serializer::WCHAR_SIZE;
}

bool operator<<(Serializer& strm, const Mod::BasicTypes& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.o))
    && (strm << stru.us)
    && (strm << stru.s)
    && (strm << stru.ul)
    && (strm << stru.l)
    && (strm << stru.ull)
    && (strm << stru.ll)
    && (strm << stru.f)
    && (strm << stru.d)
    && (strm << stru.ld)
    && (strm << ACE_OutputCDR::from_boolean(stru.b))
    && (strm << ACE_OutputCDR::from_char(stru.c))
    && (strm << stru.str.in())
    && (strm << stru.wstr.in());
}

bool operator>>(Serializer& strm, Mod::BasicTypes& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.o))
    && (strm >> stru.us)
    && (strm >> stru.s)
    && (strm >> stru.ul)
    && (strm >> stru.l)
    && (strm >> stru.ull)
    && (strm >> stru.ll)
    && (strm >> stru.f)
    && (strm >> stru.d)
    && (strm >> stru.ld)
    && (strm >> ACE_InputCDR::to_boolean(stru.b))
    && (strm >> ACE_InputCDR::to_char(stru.c))
    && (strm >> stru.str.out())
    && (strm >> stru.wstr.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Mod::BasicTypes> : MetaStruct {
  typedef Mod::BasicTypes T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const Mod::BasicTypes& typed = *static_cast<const Mod::BasicTypes*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "o") == 0) {
      return typed.o;
    }
    if (std::strcmp(field, "us") == 0) {
      return typed.us;
    }
    if (std::strcmp(field, "s") == 0) {
      return typed.s;
    }
    if (std::strcmp(field, "ul") == 0) {
      return typed.ul;
    }
    if (std::strcmp(field, "l") == 0) {
      return typed.l;
    }
    if (std::strcmp(field, "ull") == 0) {
      return typed.ull;
    }
    if (std::strcmp(field, "ll") == 0) {
      return typed.ll;
    }
    if (std::strcmp(field, "f") == 0) {
      return typed.f;
    }
    if (std::strcmp(field, "d") == 0) {
      return typed.d;
    }
    if (std::strcmp(field, "ld") == 0) {
      return typed.ld;
    }
    if (std::strcmp(field, "b") == 0) {
      return typed.b;
    }
    if (std::strcmp(field, "c") == 0) {
      return typed.c;
    }
    if (std::strcmp(field, "str") == 0) {
      return typed.str.in();
    }
    if (std::strcmp(field, "wstr") == 0) {
      return typed.wstr.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::BasicTypes)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "o") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'o' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'o' could not be skipped");
      }
    }
    if (std::strcmp(field, "us") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'us' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'us' could not be skipped");
      }
    }
    if (std::strcmp(field, "s") == 0) {
      ACE_CDR::Short val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 's' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 's' could not be skipped");
      }
    }
    if (std::strcmp(field, "ul") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'ul' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'ul' could not be skipped");
      }
    }
    if (std::strcmp(field, "l") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'l' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'l' could not be skipped");
      }
    }
    if (std::strcmp(field, "ull") == 0) {
      ACE_CDR::ULongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'ull' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 8)) {
        throw std::runtime_error("Field 'ull' could not be skipped");
      }
    }
    if (std::strcmp(field, "ll") == 0) {
      ACE_CDR::LongLong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'll' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 8)) {
        throw std::runtime_error("Field 'll' could not be skipped");
      }
    }
    if (std::strcmp(field, "f") == 0) {
      ACE_CDR::Float val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'f' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'f' could not be skipped");
      }
    }
    if (std::strcmp(field, "d") == 0) {
      ACE_CDR::Double val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'd' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 8)) {
        throw std::runtime_error("Field 'd' could not be skipped");
      }
    }
    if (std::strcmp(field, "ld") == 0) {
      ACE_CDR::LongDouble val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'ld' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 16)) {
        throw std::runtime_error("Field 'ld' could not be skipped");
      }
    }
    if (std::strcmp(field, "b") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'b' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'b' could not be skipped");
      }
    }
    if (std::strcmp(field, "c") == 0) {
      ACE_CDR::Char val;
      if (!(ser >> ACE_InputCDR::to_char(val))) {
        throw std::runtime_error("Field 'c' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'c' could not be skipped");
      }
    }
    if (std::strcmp(field, "str") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'str' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'str' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'str' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "wstr") == 0) {
      TAO::WString_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'wstr' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'wstr' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'wstr' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Mod::BasicTypes");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "o") == 0) {
      return make_field_cmp(&T::o, next);
    }
    if (std::strcmp(field, "us") == 0) {
      return make_field_cmp(&T::us, next);
    }
    if (std::strcmp(field, "s") == 0) {
      return make_field_cmp(&T::s, next);
    }
    if (std::strcmp(field, "ul") == 0) {
      return make_field_cmp(&T::ul, next);
    }
    if (std::strcmp(field, "l") == 0) {
      return make_field_cmp(&T::l, next);
    }
    if (std::strcmp(field, "ull") == 0) {
      return make_field_cmp(&T::ull, next);
    }
    if (std::strcmp(field, "ll") == 0) {
      return make_field_cmp(&T::ll, next);
    }
    if (std::strcmp(field, "f") == 0) {
      return make_field_cmp(&T::f, next);
    }
    if (std::strcmp(field, "d") == 0) {
      return make_field_cmp(&T::d, next);
    }
    if (std::strcmp(field, "ld") == 0) {
      return make_field_cmp(&T::ld, next);
    }
    if (std::strcmp(field, "b") == 0) {
      return make_field_cmp(&T::b, next);
    }
    if (std::strcmp(field, "c") == 0) {
      return make_field_cmp(&T::c, next);
    }
    if (std::strcmp(field, "str") == 0) {
      return make_field_cmp(&T::str, next);
    }
    if (std::strcmp(field, "wstr") == 0) {
      return make_field_cmp(&T::wstr, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::BasicTypes)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"o", "us", "s", "ul", "l", "ull", "ll", "f", "d", "ld", "b", "c", "str", "wstr", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "o") == 0) {
      return &static_cast<const T*>(stru)->o;
    }
    if (std::strcmp(field, "us") == 0) {
      return &static_cast<const T*>(stru)->us;
    }
    if (std::strcmp(field, "s") == 0) {
      return &static_cast<const T*>(stru)->s;
    }
    if (std::strcmp(field, "ul") == 0) {
      return &static_cast<const T*>(stru)->ul;
    }
    if (std::strcmp(field, "l") == 0) {
      return &static_cast<const T*>(stru)->l;
    }
    if (std::strcmp(field, "ull") == 0) {
      return &static_cast<const T*>(stru)->ull;
    }
    if (std::strcmp(field, "ll") == 0) {
      return &static_cast<const T*>(stru)->ll;
    }
    if (std::strcmp(field, "f") == 0) {
      return &static_cast<const T*>(stru)->f;
    }
    if (std::strcmp(field, "d") == 0) {
      return &static_cast<const T*>(stru)->d;
    }
    if (std::strcmp(field, "ld") == 0) {
      return &static_cast<const T*>(stru)->ld;
    }
    if (std::strcmp(field, "b") == 0) {
      return &static_cast<const T*>(stru)->b;
    }
    if (std::strcmp(field, "c") == 0) {
      return &static_cast<const T*>(stru)->c;
    }
    if (std::strcmp(field, "str") == 0) {
      return &static_cast<const T*>(stru)->str;
    }
    if (std::strcmp(field, "wstr") == 0) {
      return &static_cast<const T*>(stru)->wstr;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::BasicTypes)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "o") == 0) {
      static_cast<T*>(lhs)->o = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "us") == 0) {
      static_cast<T*>(lhs)->us = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "s") == 0) {
      static_cast<T*>(lhs)->s = *static_cast<const CORBA::Short*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ul") == 0) {
      static_cast<T*>(lhs)->ul = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "l") == 0) {
      static_cast<T*>(lhs)->l = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ull") == 0) {
      static_cast<T*>(lhs)->ull = *static_cast<const CORBA::ULongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ll") == 0) {
      static_cast<T*>(lhs)->ll = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "f") == 0) {
      static_cast<T*>(lhs)->f = *static_cast<const CORBA::Float*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "d") == 0) {
      static_cast<T*>(lhs)->d = *static_cast<const CORBA::Double*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ld") == 0) {
      static_cast<T*>(lhs)->ld = *static_cast<const CORBA::LongDouble*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "b") == 0) {
      static_cast<T*>(lhs)->b = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "c") == 0) {
      static_cast<T*>(lhs)->c = *static_cast<const CORBA::Char*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "str") == 0) {
      static_cast<T*>(lhs)->str = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "wstr") == 0) {
      static_cast<T*>(lhs)->wstr = *static_cast<const TAO::WString_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::BasicTypes)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "o") == 0) {
      return static_cast<const T*>(lhs)->o == static_cast<const T*>(rhs)->o;
    }
    if (std::strcmp(field, "us") == 0) {
      return static_cast<const T*>(lhs)->us == static_cast<const T*>(rhs)->us;
    }
    if (std::strcmp(field, "s") == 0) {
      return static_cast<const T*>(lhs)->s == static_cast<const T*>(rhs)->s;
    }
    if (std::strcmp(field, "ul") == 0) {
      return static_cast<const T*>(lhs)->ul == static_cast<const T*>(rhs)->ul;
    }
    if (std::strcmp(field, "l") == 0) {
      return static_cast<const T*>(lhs)->l == static_cast<const T*>(rhs)->l;
    }
    if (std::strcmp(field, "ull") == 0) {
      return static_cast<const T*>(lhs)->ull == static_cast<const T*>(rhs)->ull;
    }
    if (std::strcmp(field, "ll") == 0) {
      return static_cast<const T*>(lhs)->ll == static_cast<const T*>(rhs)->ll;
    }
    if (std::strcmp(field, "f") == 0) {
      return static_cast<const T*>(lhs)->f == static_cast<const T*>(rhs)->f;
    }
    if (std::strcmp(field, "d") == 0) {
      return static_cast<const T*>(lhs)->d == static_cast<const T*>(rhs)->d;
    }
    if (std::strcmp(field, "ld") == 0) {
      return static_cast<const T*>(lhs)->ld == static_cast<const T*>(rhs)->ld;
    }
    if (std::strcmp(field, "b") == 0) {
      return static_cast<const T*>(lhs)->b == static_cast<const T*>(rhs)->b;
    }
    if (std::strcmp(field, "c") == 0) {
      return static_cast<const T*>(lhs)->c == static_cast<const T*>(rhs)->c;
    }
    if (std::strcmp(field, "str") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->str.in(), static_cast<const T*>(rhs)->str.in());
    }
    if (std::strcmp(field, "wstr") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->wstr.in(), static_cast<const T*>(rhs)->wstr.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::BasicTypes)");
  }
};

template<>
const MetaStruct& getMetaStruct<Mod::BasicTypes>()
{
  static MetaStructImpl<Mod::BasicTypes> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, Mod::BasicTypes*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Mod::BasicTypes>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::BasicTypes& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Object> stru = Nan::New<v8::Object>();
  stru->Set(Nan::New<v8::String>("o").ToLocalChecked(), Nan::New(src.o));
  stru->Set(Nan::New<v8::String>("us").ToLocalChecked(), Nan::New(src.us));
  stru->Set(Nan::New<v8::String>("s").ToLocalChecked(), Nan::New(src.s));
  stru->Set(Nan::New<v8::String>("ul").ToLocalChecked(), Nan::New(src.ul));
  stru->Set(Nan::New<v8::String>("l").ToLocalChecked(), Nan::New(src.l));
  stru->Set(Nan::New<v8::String>("ull").ToLocalChecked(), Nan::New(std::to_string(src.ull).c_str()).ToLocalChecked());
  stru->Set(Nan::New<v8::String>("ll").ToLocalChecked(), Nan::New(std::to_string(src.ll).c_str()).ToLocalChecked());
  stru->Set(Nan::New<v8::String>("f").ToLocalChecked(), Nan::New(static_cast<double>(src.f)));
  stru->Set(Nan::New<v8::String>("d").ToLocalChecked(), Nan::New(static_cast<double>(src.d)));
  stru->Set(Nan::New<v8::String>("ld").ToLocalChecked(), Nan::New(static_cast<double>(src.ld)));
  stru->Set(Nan::New<v8::String>("b").ToLocalChecked(), Nan::New(src.b));
  {
    const char str[] = {src.c, 0};
    stru->Set(Nan::New<v8::String>("c").ToLocalChecked(), Nan::New(str).ToLocalChecked());
  }
  stru->Set(Nan::New<v8::String>("str").ToLocalChecked(), Nan::New(src.str.in()).ToLocalChecked());
  {
    const size_t len = ACE_OS::strlen(src.wstr.in());
    uint16_t* const str = new uint16_t[len + 1];
    for (size_t i = 0; i <= len; ++i) {
      str[i] = src.wstr[i];
    }
    stru->Set(Nan::New<v8::String>("wstr").ToLocalChecked(), Nan::New(str).ToLocalChecked());
    delete[] str;
  }
  return stru;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::BasicTypes& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  {
    v8::Local<v8::String> field_str = Nan::New("o").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          uint16_t temp_CORBA_Octet;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_Octet;
          } else {
            iss >> temp_CORBA_Octet;
          }
          out.o = temp_CORBA_Octet;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.o = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("us").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::UShort temp_CORBA_UShort;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_UShort;
          } else {
            iss >> temp_CORBA_UShort;
          }
          out.us = temp_CORBA_UShort;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.us = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("s").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::Short temp_CORBA_Short;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_Short;
          } else {
            iss >> temp_CORBA_Short;
          }
          out.s = temp_CORBA_Short;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.s = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ul").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::ULong temp_CORBA_ULong;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_ULong;
          } else {
            iss >> temp_CORBA_ULong;
          }
          out.ul = temp_CORBA_ULong;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.ul = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("l").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::Long temp_CORBA_Long;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_Long;
          } else {
            iss >> temp_CORBA_Long;
          }
          out.l = temp_CORBA_Long;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.l = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ull").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::ULongLong temp_CORBA_ULongLong;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_ULongLong;
          } else {
            iss >> temp_CORBA_ULongLong;
          }
          out.ull = temp_CORBA_ULongLong;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.ull = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ll").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::LongLong temp_CORBA_LongLong;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_LongLong;
          } else {
            iss >> temp_CORBA_LongLong;
          }
          out.ll = temp_CORBA_LongLong;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.ll = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("f").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.f = ln->Value();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("d").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.d = ln->Value();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ld").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.ld = ln->Value();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("b").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsBoolean()) {
          v8::Local<v8::Boolean> lb = Nan::To<v8::Boolean>(lv).ToLocalChecked();
          out.b = lb->Value();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("c").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          char temp_c;
          ls->WriteUtf8(&temp_c, 1);
          out.c = temp_c;
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("str").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          out.str = ss.c_str();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("wstr").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::vector<uint16_t> vwc(ls->Length(), 0);
          ls->Write(&vwc[0]);
          std::wstring ws(ls->Length(), ' ');
          for (size_t i = 0; i < vwc.size(); ++i) {
            ws[i] = vwc[i];
          }
          out.wstr = ws.c_str();
        }
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BasicTypes */


/* Begin TYPEDEF: MySeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MySeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Short());
}

bool operator<<(Serializer& strm, const Mod::MySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_short_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, Mod::MySeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_short_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::MySeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(static_cast<ACE_UINT16>(length), 2);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MySeq& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(src.length()));
  for (CORBA::ULong i = 0; i < src.length(); ++i) {
    tgt->Set(i, Nan::New(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MySeq& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
  }
  out.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
      if (lv->IsString()) {
        v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
        std::string ss(ls->Utf8Length(), ' ');
        ls->WriteUtf8(&ss[0]);
        std::istringstream iss(ss);
        CORBA::Short temp_CORBA_Short;
        if (ss.find("0x") != std::string::npos) {
          iss >> std::hex >> temp_CORBA_Short;
        } else {
          iss >> temp_CORBA_Short;
        }
        out[i] = temp_CORBA_Short;
      }
      if (lv->IsNumber()) {
        v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
        out[i] = ln->IntegerValue();
      }
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MySeq */


/* Begin TYPEDEF: NestedSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::NestedSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Mod::NestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::NestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::NestedSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<CORBA::StringSeq*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::NestedSeq& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(src.length()));
  for (CORBA::ULong i = 0; i < src.length(); ++i) {
    {
    const v8::Local<v8::Array> seq = Nan::New<v8::Array>(src[i].length());
    for (CORBA::ULong j = 0; j < src[i].length(); ++j) {
  seq->Set(j, Nan::New(src[i][j].in()).ToLocalChecked());
    }
    tgt->Set(i, seq);
  }
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::NestedSeq& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
  }
  out.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
      v8::Local<v8::Value> lv = src->Get(i);
      if (lv->IsArray()) {
        uint32_t length = 0;
        v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
        length = lo->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
        CORBA::StringSeq& temp = out[i];
        temp.length(length);
        for (uint32_t i = 0; i < length; ++i) {
          {
    v8::Local<v8::Value> lv = lo->Get(i);
      if (lv->IsString()) {
        v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
        std::string ss(ls->Utf8Length(), ' ');
        ls->WriteUtf8(&ss[0]);
        temp[i] = ss.c_str();
      }
  }
        }
      }
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: NestedSeq */


/* Begin UNION: MyUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MyUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += max_marshaled_size_ulong();
  switch (uni._d()) {
  case Mod::one: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.a());
    break;
  }
  case Mod::two: {
    size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(uni.b()));
    break;
  }
  case Mod::three: {
    if ((size + padding) % 8) {
      padding += 8 - ((size + padding) % 8);
    }
    size += gen_max_marshaled_size(uni.d());
    break;
  }
  case Mod::four: {
    gen_find_size(uni.s(), size, padding);
    break;
  }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const Mod::MyUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case Mod::one: {
    return (strm << uni.a());
  }
  case Mod::two: {
    return (strm << ACE_OutputCDR::from_boolean(uni.b()));
  }
  case Mod::three: {
    return (strm << uni.d());
  }
  case Mod::four: {
    return (strm << uni.s());
  }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::MyUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  Mod::MyEnum disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case Mod::one: {
    CORBA::Long tmp;
    if (strm >> tmp) {
      uni.a(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case Mod::two: {
    CORBA::Boolean tmp;
    if (strm >> ACE_InputCDR::to_boolean(tmp)) {
      uni.b(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case Mod::three: {
    CORBA::Double tmp;
    if (strm >> tmp) {
      uni.d(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case Mod::four: {
    Mod::NestedSeq tmp;
    if (strm >> tmp) {
      uni.s(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Mod::MyUnion> : MetaStruct {
  typedef Mod::MyUnion T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const Mod::MyUnion& typed = *static_cast<const Mod::MyUnion*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyUnion)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Mod::MyUnion");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyUnion)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyUnion)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyUnion)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyUnion)");
  }
};

template<>
const MetaStruct& getMetaStruct<Mod::MyUnion>()
{
  static MetaStructImpl<Mod::MyUnion> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, Mod::MyUnion*)
{
  ACE_UNUSED_ARG(ser);
  Mod::MyEnum disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case Mod::one: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case Mod::two: {
    if (!ser.skip(1, 1)) return false;
    return true;
  }
  case Mod::three: {
    if (!ser.skip(1, 8)) return false;
    return true;
  }
  case Mod::four: {
    if (!gen_skip_over(ser, static_cast<Mod::NestedSeq*>(0))) return false;
    return true;
  }
  default:
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MyUnion& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Object> uni = Nan::New<v8::Object>();
  uni->Set(Nan::New<v8::String>("_d").ToLocalChecked(), Nan::New((src._d() >= gen_Mod_MyEnum_names_size) ? "<<invalid>>" : gen_Mod_MyEnum_names[static_cast<int>(src._d())]).ToLocalChecked());
  switch (src._d()) {
  case Mod::one: {
    uni->Set(Nan::New<v8::String>("a").ToLocalChecked(), Nan::New(src.a()));
    break;
  }
  case Mod::two: {
    uni->Set(Nan::New<v8::String>("b").ToLocalChecked(), Nan::New(src.b()));
    break;
  }
  case Mod::three: {
    uni->Set(Nan::New<v8::String>("d").ToLocalChecked(), Nan::New(static_cast<double>(src.d())));
    break;
  }
  case Mod::four: {
    uni->Set(Nan::New<v8::String>("s").ToLocalChecked(), copyToV8(src.s()));
    break;
  }
  default:
    break;
  }
  return uni;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MyUnion& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  {
    v8::Local<v8::String> field_str = Nan::New("_d").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Integer> li = Nan::To<v8::Integer>(lv).ToLocalChecked();
          out._d(static_cast<Mod::MyEnum>(li->Value()));
        }
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          for (uint32_t i = 0; i < gen_Mod_MyEnum_names_size; ++i) {
            if (ss == gen_Mod_MyEnum_names[i]) {
              out._d(static_cast<Mod::MyEnum>(i));
              break;
            }
          }
        }
    }
  }
  switch (out._d()) {
  case Mod::one: {
    {
    v8::Local<v8::String> field_str = Nan::New("a").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::Long temp_CORBA_Long;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_Long;
          } else {
            iss >> temp_CORBA_Long;
          }
          out.a(temp_CORBA_Long);
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.a(ln->IntegerValue());
        }
    }
  }
    break;
  }
  case Mod::two: {
    {
    v8::Local<v8::String> field_str = Nan::New("b").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsBoolean()) {
          v8::Local<v8::Boolean> lb = Nan::To<v8::Boolean>(lv).ToLocalChecked();
          out.b(lb->Value());
        }
    }
  }
    break;
  }
  case Mod::three: {
    {
    v8::Local<v8::String> field_str = Nan::New("d").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.d(ln->Value());
        }
    }
  }
    break;
  }
  case Mod::four: {
  out.s(Mod::NestedSeq());
    {
    v8::Local<v8::String> field_str = Nan::New("s").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.s());
    }
  }
    break;
  }
  default:
    break;
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End UNION: MyUnion */


/* Begin TYPEDEF: NestedNestedSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::NestedNestedSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Mod::NestedNestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::NestedNestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::NestedNestedSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<Mod::NestedSeq*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::NestedNestedSeq& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(src.length()));
  for (CORBA::ULong i = 0; i < src.length(); ++i) {
    tgt->Set(i, copyToV8(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::NestedNestedSeq& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
  }
  out.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
    v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
    copyFromV8(lo, out[i]);
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: NestedNestedSeq */


/* Begin TYPEDEF: NestedNestedNestedSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::NestedNestedNestedSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Mod::NestedNestedNestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::NestedNestedNestedSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::NestedNestedNestedSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<Mod::NestedNestedSeq*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::NestedNestedNestedSeq& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(src.length()));
  for (CORBA::ULong i = 0; i < src.length(); ++i) {
    tgt->Set(i, copyToV8(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::NestedNestedNestedSeq& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
  }
  out.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
    v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
    copyFromV8(lo, out[i]);
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: NestedNestedNestedSeq */


/* Begin TYPEDEF: CharArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::CharArray_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 6 * max_marshaled_size_char();
}

bool operator<<(Serializer& strm, const Mod::CharArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_char_array(arr.in(), 6);
}

bool operator>>(Serializer& strm, Mod::CharArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_char_array(arr.out(), 6);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::CharArray_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(6), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::CharArray& src)
{
  ACE_UNUSED_ARG(src);
  CORBA::ULong length = sizeof(src) / sizeof(src[0]);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(length));
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    const char str[] = {src[i], 0};
    tgt->Set(i, Nan::New(str).ToLocalChecked());
  }
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::CharArray& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    CORBA::ULong src_length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
    CORBA::ULong out_length = (sizeof(out) / sizeof(out[0]));
    length = (src_length <= out_length) ? src_length : out_length;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
      if (lv->IsString()) {
        v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
        char temp_c;
        ls->WriteUtf8(&temp_c, 1);
        out[i] = temp_c;
      }
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: CharArray */


/* Begin TYPEDEF: StringArray */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::StringArray_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(arr[i0].in()) + 1;
  }
}

bool operator<<(Serializer& strm, const Mod::StringArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
    if (!(strm << arr[i0].in())) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::StringArray_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
    if (!(strm >> arr[i0].out())) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::StringArray_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 4; ++i) {
    ACE_CDR::ULong strlength;
    if (!(ser >> strlength)) return false;
    if (!ser.skip(static_cast<ACE_UINT16>(strlength))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::StringArray& src)
{
  ACE_UNUSED_ARG(src);
  CORBA::ULong length = sizeof(src) / sizeof(src[0]);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(length));
  for (CORBA::ULong i = 0; i < length; ++i) {
    tgt->Set(i, Nan::New(src[i].in()).ToLocalChecked());
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::StringArray& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    CORBA::ULong src_length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
    CORBA::ULong out_length = (sizeof(out) / sizeof(out[0]));
    length = (src_length <= out_length) ? src_length : out_length;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
      if (lv->IsString()) {
        v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
        std::string ss(ls->Utf8Length(), ' ');
        ls->WriteUtf8(&ss[0]);
        out[i] = ss.c_str();
      }
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: StringArray */


/* Begin STRUCT: Sample */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::Sample& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Mod::CharArray_forany stru_ca(const_cast<Mod::CharArray_slice*>(stru.ca));
  Mod::StringArray_forany stru_sa(const_cast<Mod::StringArray_slice*>(stru.sa));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.id);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.data.in()) + 1;
  find_size_ulong(size, padding);
  find_size_ulong(size, padding);
  gen_find_size(stru.bt, size, padding);
  gen_find_size(stru.seq1, size, padding);
  gen_find_size(stru.seq2, size, padding);
  gen_find_size(stru.ns, size, padding);
  gen_find_size(stru.mu, size, padding);
  gen_find_size(stru_ca, size, padding);
  gen_find_size(stru_sa, size, padding);
}

bool operator<<(Serializer& strm, const Mod::Sample& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Mod::CharArray_forany stru_ca(const_cast<Mod::CharArray_slice*>(stru.ca));
  Mod::StringArray_forany stru_sa(const_cast<Mod::StringArray_slice*>(stru.sa));
  return (strm << stru.id)
    && (strm << stru.data.in())
    && (strm << stru.enu)
    && (strm << stru.enu2)
    && (strm << stru.bt)
    && (strm << stru.seq1)
    && (strm << stru.seq2)
    && (strm << stru.ns)
    && (strm << stru.mu)
    && (strm << stru_ca)
    && (strm << stru_sa);
}

bool operator>>(Serializer& strm, Mod::Sample& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Mod::CharArray_forany stru_ca(const_cast<Mod::CharArray_slice*>(stru.ca));
  Mod::StringArray_forany stru_sa(const_cast<Mod::StringArray_slice*>(stru.sa));
  return (strm >> stru.id)
    && (strm >> stru.data.out())
    && (strm >> stru.enu)
    && (strm >> stru.enu2)
    && (strm >> stru.bt)
    && (strm >> stru.seq1)
    && (strm >> stru.seq2)
    && (strm >> stru.ns)
    && (strm >> stru.mu)
    && (strm >> stru_ca)
    && (strm >> stru_sa);
}

size_t gen_max_marshaled_size(const Mod::Sample& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Mod::Sample> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 4;
}

void gen_find_size(KeyOnly<const Mod::Sample> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.t.id);
}

bool operator<<(Serializer& strm, KeyOnly<const Mod::Sample> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.t.id);
}

bool operator>>(Serializer& strm, KeyOnly<Mod::Sample> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.t.id);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Mod {
::DDS::DataWriter_ptr SampleTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<Sample> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr SampleTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Sample> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr SampleTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<Sample> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<Sample, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& SampleTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Sample>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool SampleTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* SampleTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

SampleTypeSupport::_ptr_type SampleTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Mod::Sample> : MetaStruct {
  typedef Mod::Sample T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 1; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    if (!ACE_OS::strcmp(field, "id")) {
      return true;
    }
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const Mod::Sample& typed = *static_cast<const Mod::Sample*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "id") == 0) {
      return typed.id;
    }
    if (std::strcmp(field, "data") == 0) {
      return typed.data.in();
    }
    if (std::strcmp(field, "enu") == 0) {
      return gen_Mod_MyEnum_names[typed.enu];
    }
    if (std::strcmp(field, "enu2") == 0) {
      return gen_Mod_MyEnum_names[typed.enu2];
    }
    if (std::strncmp(field, "bt.", 3) == 0) {
      return getMetaStruct<Mod::BasicTypes>().getValue(&typed.bt, field + 3);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::Sample)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'id' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'id' could not be skipped");
      }
    }
    if (std::strcmp(field, "data") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'data' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'data' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'data' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "enu") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'enu' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'enu' could not be skipped");
      }
    }
    if (std::strcmp(field, "enu2") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'enu2' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'enu2' could not be skipped");
      }
    }
    if (std::strncmp(field, "bt.", 3) == 0) {
      return getMetaStruct<Mod::BasicTypes>().getValue(ser, field + 3);
    } else {
      if (!gen_skip_over(ser, static_cast<Mod::BasicTypes*>(0))) {
        throw std::runtime_error("Field 'bt' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<Mod::MySeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<CORBA::LongSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<Mod::NestedSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<Mod::MyUnion*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<Mod::CharArray_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<Mod::StringArray_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Mod::Sample");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "id") == 0) {
      return make_field_cmp(&T::id, next);
    }
    if (std::strcmp(field, "data") == 0) {
      return make_field_cmp(&T::data, next);
    }
    if (std::strcmp(field, "enu") == 0) {
      return make_field_cmp(&T::enu, next);
    }
    if (std::strcmp(field, "enu2") == 0) {
      return make_field_cmp(&T::enu2, next);
    }
    if (std::strncmp(field, "bt.", 3) == 0) {
      return make_struct_cmp(&T::bt, getMetaStruct<Mod::BasicTypes>().create_qc_comparator(field + 3), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::Sample)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"id", "data", "enu", "enu2", "bt", "seq1", "seq2", "ns", "mu", "ca", "sa", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "id") == 0) {
      return &static_cast<const T*>(stru)->id;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    if (std::strcmp(field, "enu") == 0) {
      return &static_cast<const T*>(stru)->enu;
    }
    if (std::strcmp(field, "enu2") == 0) {
      return &static_cast<const T*>(stru)->enu2;
    }
    if (std::strcmp(field, "bt") == 0) {
      return &static_cast<const T*>(stru)->bt;
    }
    if (std::strcmp(field, "seq1") == 0) {
      return &static_cast<const T*>(stru)->seq1;
    }
    if (std::strcmp(field, "seq2") == 0) {
      return &static_cast<const T*>(stru)->seq2;
    }
    if (std::strcmp(field, "ns") == 0) {
      return &static_cast<const T*>(stru)->ns;
    }
    if (std::strcmp(field, "mu") == 0) {
      return &static_cast<const T*>(stru)->mu;
    }
    if (std::strcmp(field, "ca") == 0) {
      return &static_cast<const T*>(stru)->ca;
    }
    if (std::strcmp(field, "sa") == 0) {
      return &static_cast<const T*>(stru)->sa;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::Sample)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "id") == 0) {
      static_cast<T*>(lhs)->id = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "enu") == 0) {
      static_cast<T*>(lhs)->enu = *static_cast<const Mod::MyEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "enu2") == 0) {
      static_cast<T*>(lhs)->enu2 = *static_cast<const Mod::MyEnum*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bt") == 0) {
      static_cast<T*>(lhs)->bt = *static_cast<const Mod::BasicTypes*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "seq1") == 0) {
      static_cast<T*>(lhs)->seq1 = *static_cast<const Mod::MySeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "seq2") == 0) {
      static_cast<T*>(lhs)->seq2 = *static_cast<const CORBA::LongSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ns") == 0) {
      static_cast<T*>(lhs)->ns = *static_cast<const Mod::NestedSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "mu") == 0) {
      static_cast<T*>(lhs)->mu = *static_cast<const Mod::MyUnion*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "ca") == 0) {
      Mod::CharArray* lhsArr = &static_cast<T*>(lhs)->ca;
      const Mod::CharArray* rhsArr = static_cast<const Mod::CharArray*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 6; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "sa") == 0) {
      Mod::StringArray* lhsArr = &static_cast<T*>(lhs)->sa;
      const Mod::StringArray* rhsArr = static_cast<const Mod::StringArray*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::Sample)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "id") == 0) {
      return static_cast<const T*>(lhs)->id == static_cast<const T*>(rhs)->id;
    }
    if (std::strcmp(field, "data") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->data.in(), static_cast<const T*>(rhs)->data.in());
    }
    if (std::strcmp(field, "enu") == 0) {
      return static_cast<const T*>(lhs)->enu == static_cast<const T*>(rhs)->enu;
    }
    if (std::strcmp(field, "enu2") == 0) {
      return static_cast<const T*>(lhs)->enu2 == static_cast<const T*>(rhs)->enu2;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::Sample)");
  }
};

template<>
const MetaStruct& getMetaStruct<Mod::Sample>()
{
  static MetaStructImpl<Mod::Sample> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, Mod::Sample*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Mod::Sample>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::Sample& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Object> stru = Nan::New<v8::Object>();
  stru->Set(Nan::New<v8::String>("id").ToLocalChecked(), Nan::New(src.id));
  stru->Set(Nan::New<v8::String>("data").ToLocalChecked(), Nan::New(src.data.in()).ToLocalChecked());
  stru->Set(Nan::New<v8::String>("enu").ToLocalChecked(), Nan::New((src.enu >= gen_Mod_MyEnum_names_size) ? "<<invalid>>" : gen_Mod_MyEnum_names[static_cast<int>(src.enu)]).ToLocalChecked());
  stru->Set(Nan::New<v8::String>("enu2").ToLocalChecked(), Nan::New((src.enu2 >= gen_Mod_MyEnum_names_size) ? "<<invalid>>" : gen_Mod_MyEnum_names[static_cast<int>(src.enu2)]).ToLocalChecked());
  stru->Set(Nan::New<v8::String>("bt").ToLocalChecked(), copyToV8(src.bt));
  stru->Set(Nan::New<v8::String>("seq1").ToLocalChecked(), copyToV8(src.seq1));
  {
    const v8::Local<v8::Array> seq = Nan::New<v8::Array>(src.seq2.length());
    for (CORBA::ULong j = 0; j < src.seq2.length(); ++j) {
  seq->Set(j, Nan::New(src.seq2[j]));
    }
    stru->Set(Nan::New<v8::String>("seq2").ToLocalChecked(), seq);
  }
  stru->Set(Nan::New<v8::String>("ns").ToLocalChecked(), copyToV8(src.ns));
  stru->Set(Nan::New<v8::String>("mu").ToLocalChecked(), copyToV8(src.mu));
  stru->Set(Nan::New<v8::String>("ca").ToLocalChecked(), copyToV8(src.ca));
  stru->Set(Nan::New<v8::String>("sa").ToLocalChecked(), copyToV8(src.sa));
  return stru;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::Sample& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  {
    v8::Local<v8::String> field_str = Nan::New("id").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          std::istringstream iss(ss);
          CORBA::Long temp_CORBA_Long;
          if (ss.find("0x") != std::string::npos) {
            iss >> std::hex >> temp_CORBA_Long;
          } else {
            iss >> temp_CORBA_Long;
          }
          out.id = temp_CORBA_Long;
        }
        if (lv->IsNumber()) {
          v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
          out.id = ln->IntegerValue();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("data").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          out.data = ss.c_str();
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("enu").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Integer> li = Nan::To<v8::Integer>(lv).ToLocalChecked();
          out.enu = static_cast<Mod::MyEnum>(li->Value());
        }
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          for (uint32_t i = 0; i < gen_Mod_MyEnum_names_size; ++i) {
            if (ss == gen_Mod_MyEnum_names[i]) {
              out.enu = static_cast<Mod::MyEnum>(i);
              break;
            }
          }
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("enu2").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Integer> li = Nan::To<v8::Integer>(lv).ToLocalChecked();
          out.enu2 = static_cast<Mod::MyEnum>(li->Value());
        }
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          for (uint32_t i = 0; i < gen_Mod_MyEnum_names_size; ++i) {
            if (ss == gen_Mod_MyEnum_names[i]) {
              out.enu2 = static_cast<Mod::MyEnum>(i);
              break;
            }
          }
        }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("bt").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.bt);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("seq1").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.seq1);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("seq2").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      if (lv->IsArray()) {
        uint32_t length = 0;
        v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
        length = lo->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
        CORBA::LongSeq& temp = out.seq2;
        temp.length(length);
        for (uint32_t i = 0; i < length; ++i) {
          {
    v8::Local<v8::Value> lv = lo->Get(i);
      if (lv->IsString()) {
        v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
        std::string ss(ls->Utf8Length(), ' ');
        ls->WriteUtf8(&ss[0]);
        std::istringstream iss(ss);
        CORBA::Long temp_CORBA_Long;
        if (ss.find("0x") != std::string::npos) {
          iss >> std::hex >> temp_CORBA_Long;
        } else {
          iss >> temp_CORBA_Long;
        }
        temp[i] = temp_CORBA_Long;
      }
      if (lv->IsNumber()) {
        v8::Local<v8::Number> ln = Nan::To<v8::Number>(lv).ToLocalChecked();
        temp[i] = ln->IntegerValue();
      }
  }
        }
      }
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ns").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.ns);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("mu").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.mu);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("ca").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.ca);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("sa").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.sa);
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Mod {
class SampleTypeSupportV8Impl
  : public virtual SampleTypeSupportImpl
  , public virtual OpenDDS::DCPS::V8TypeConverter {

  v8::Local<v8::Object> toV8(const void* source) const
  {
    return OpenDDS::DCPS::copyToV8(*static_cast<const Sample*>(source));
  }

  void* fromV8(const v8::Local<v8::Object>& source) const
  {
    Sample* result = new Sample();
    OpenDDS::DCPS::copyFromV8(source, *result);
    return result;
  }

  void deleteFromV8Result(void* val) const
  {
    Sample* delete_me = static_cast< Sample*>(val);
    delete delete_me;
  }

  DDS::InstanceHandle_t register_instance_helper(DDS::DataWriter* dw, const void* data) const
  {
    SampleDataWriter* dw_t = dynamic_cast<SampleDataWriter*>(dw);
    return dw_t ? dw_t->register_instance(*static_cast<const Sample*>(data)) : DDS::HANDLE_NIL;
  }

  DDS::ReturnCode_t write_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    SampleDataWriter* dw_t = dynamic_cast<SampleDataWriter*>(dw);
    return dw_t ? dw_t->write(*static_cast<const Sample*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

  DDS::ReturnCode_t unregister_instance_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    SampleDataWriter* dw_t = dynamic_cast<SampleDataWriter*>(dw);
    return dw_t ? dw_t->unregister_instance(*static_cast<const Sample*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

  DDS::ReturnCode_t dispose_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    SampleDataWriter* dw_t = dynamic_cast<SampleDataWriter*>(dw);
    return dw_t ? dw_t->dispose(*static_cast<const Sample*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

public:
  struct Initializer {
    Initializer()
    {
      SampleTypeSupport_var ts = new SampleTypeSupportV8Impl;
      ts->register_type(0, "");
    }
  };
};

SampleTypeSupportV8Impl::Initializer init_tsv8_Sample;

}

/* End STRUCT: Sample */


/* Begin TYPEDEF: MyUnionSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MyUnionSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const Mod::MyUnionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::MyUnionSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::MyUnionSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MyUnionSeq& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(src.length()));
  for (CORBA::ULong i = 0; i < src.length(); ++i) {
    tgt->Set(i, copyToV8(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MyUnionSeq& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
  }
  out.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
    v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
    copyFromV8(lo, out[i]);
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MyUnionSeq */


/* Begin ENUM: MyOtherEnum */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const Mod::MyOtherEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, Mod::MyOtherEnum& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<Mod::MyOtherEnum>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_Mod_MyOtherEnum_names[] = {
  "small",
  "medium",
  "large"
};
const size_t gen_Mod_MyOtherEnum_names_size = 3;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: MyOtherEnum */


/* Begin UNION: MyOtherUnion */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MyOtherUnion& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += max_marshaled_size_ulong();
  switch (uni._d()) {
  case Mod::small: {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(uni.one()) + 1;
    break;
  }
  case Mod::medium: {
    gen_find_size(uni.two(), size, padding);
    break;
  }
  case Mod::large: {
    gen_find_size(uni.three(), size, padding);
    break;
  }
  default:
    break;
  }
}

bool operator<<(Serializer& strm, const Mod::MyOtherUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  if (!(strm << uni._d())) {
    return false;
  }
  switch (uni._d()) {
  case Mod::small: {
    return (strm << uni.one());
  }
  case Mod::medium: {
    return (strm << uni.two());
  }
  case Mod::large: {
    return (strm << uni.three());
  }
  default:
    break;
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::MyOtherUnion& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  Mod::MyOtherEnum disc;
  if (!(strm >> disc)) {
    return false;
  }
  switch (disc) {
  case Mod::small: {
    CORBA::String_var tmp;
    if (strm >> tmp.out()) {
      uni.one(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case Mod::medium: {
    Mod::NestedSeq tmp;
    if (strm >> tmp) {
      uni.two(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case Mod::large: {
    Mod::Sample tmp;
    if (strm >> tmp) {
      uni.three(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  default:
    uni._d(disc);
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Mod::MyOtherUnion> : MetaStruct {
  typedef Mod::MyOtherUnion T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const Mod::MyOtherUnion& typed = *static_cast<const Mod::MyOtherUnion*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyOtherUnion)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Mod::MyOtherUnion");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyOtherUnion)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyOtherUnion)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyOtherUnion)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MyOtherUnion)");
  }
};

template<>
const MetaStruct& getMetaStruct<Mod::MyOtherUnion>()
{
  static MetaStructImpl<Mod::MyOtherUnion> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, Mod::MyOtherUnion*)
{
  ACE_UNUSED_ARG(ser);
  Mod::MyOtherEnum disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case Mod::small: {
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(static_cast<ACE_UINT16>(len))) return false;
    return true;
  }
  case Mod::medium: {
    if (!gen_skip_over(ser, static_cast<Mod::NestedSeq*>(0))) return false;
    return true;
  }
  case Mod::large: {
    if (!gen_skip_over(ser, static_cast<Mod::Sample*>(0))) return false;
    return true;
  }
  default:
    break;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MyOtherUnion& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Object> uni = Nan::New<v8::Object>();
  uni->Set(Nan::New<v8::String>("_d").ToLocalChecked(), Nan::New((src._d() >= gen_Mod_MyOtherEnum_names_size) ? "<<invalid>>" : gen_Mod_MyOtherEnum_names[static_cast<int>(src._d())]).ToLocalChecked());
  switch (src._d()) {
  case Mod::small: {
    uni->Set(Nan::New<v8::String>("one").ToLocalChecked(), Nan::New(src.one()).ToLocalChecked());
    break;
  }
  case Mod::medium: {
    uni->Set(Nan::New<v8::String>("two").ToLocalChecked(), copyToV8(src.two()));
    break;
  }
  case Mod::large: {
    uni->Set(Nan::New<v8::String>("three").ToLocalChecked(), copyToV8(src.three()));
    break;
  }
  default:
    break;
  }
  return uni;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MyOtherUnion& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  {
    v8::Local<v8::String> field_str = Nan::New("_d").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsNumber()) {
          v8::Local<v8::Integer> li = Nan::To<v8::Integer>(lv).ToLocalChecked();
          out._d(static_cast<Mod::MyOtherEnum>(li->Value()));
        }
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          for (uint32_t i = 0; i < gen_Mod_MyOtherEnum_names_size; ++i) {
            if (ss == gen_Mod_MyOtherEnum_names[i]) {
              out._d(static_cast<Mod::MyOtherEnum>(i));
              break;
            }
          }
        }
    }
  }
  switch (out._d()) {
  case Mod::small: {
    {
    v8::Local<v8::String> field_str = Nan::New("one").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
        if (lv->IsString()) {
          v8::Local<v8::String> ls = Nan::To<v8::String>(lv).ToLocalChecked();
          std::string ss(ls->Utf8Length(), ' ');
          ls->WriteUtf8(&ss[0]);
          out.one(ss.c_str());
        }
    }
  }
    break;
  }
  case Mod::medium: {
  out.two(Mod::NestedSeq());
    {
    v8::Local<v8::String> field_str = Nan::New("two").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.two());
    }
  }
    break;
  }
  case Mod::large: {
  out.three(Mod::Sample());
    {
    v8::Local<v8::String> field_str = Nan::New("three").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.three());
    }
  }
    break;
  }
  default:
    break;
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End UNION: MyOtherUnion */


/* Begin TYPEDEF: JunkType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::JunkType_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
    gen_find_size(arr[i0], size, padding);
  }
}

bool operator<<(Serializer& strm, const Mod::JunkType_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
    if (!(strm << arr[i0])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, Mod::JunkType_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
    if (!(strm >> arr[i0])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::JunkType_forany*)
{
  ACE_UNUSED_ARG(ser);
  for (ACE_CDR::ULong i = 0; i < 2; ++i) {
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::JunkType& src)
{
  ACE_UNUSED_ARG(src);
  CORBA::ULong length = sizeof(src) / sizeof(src[0]);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(length));
  for (CORBA::ULong i = 0; i < length; ++i) {
    tgt->Set(i, copyToV8(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::JunkType& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    CORBA::ULong src_length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
    CORBA::ULong out_length = (sizeof(out) / sizeof(out[0]));
    length = (src_length <= out_length) ? src_length : out_length;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
    v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
    copyFromV8(lo, out[i]);
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: JunkType */


/* Begin TYPEDEF: MaskType */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MaskType_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 2 * max_marshaled_size_boolean();
}

bool operator<<(Serializer& strm, const Mod::MaskType_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_boolean_array(arr.in(), 2);
}

bool operator>>(Serializer& strm, Mod::MaskType_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_boolean_array(arr.out(), 2);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, Mod::MaskType_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(2), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MaskType& src)
{
  ACE_UNUSED_ARG(src);
  CORBA::ULong length = sizeof(src) / sizeof(src[0]);
  const v8::Local<v8::Array> tgt(Nan::New<v8::Array>(length));
  for (CORBA::ULong i = 0; i < length; ++i) {
    tgt->Set(i, Nan::New(src[i]));
  }
  return tgt;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MaskType& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  CORBA::ULong length = 0;
  if (src->IsArray()) {
    CORBA::ULong src_length = src->Get(Nan::New("length").ToLocalChecked())->ToObject()->Uint32Value();
    CORBA::ULong out_length = (sizeof(out) / sizeof(out[0]));
    length = (src_length <= out_length) ? src_length : out_length;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    {
    v8::Local<v8::Value> lv = src->Get(i);
      if (lv->IsBoolean()) {
        v8::Local<v8::Boolean> lb = Nan::To<v8::Boolean>(lv).ToLocalChecked();
        out[i] = lb->Value();
      }
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: MaskType */


/* Begin STRUCT: MaskedJunk */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const Mod::MaskedJunk& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  Mod::JunkType_forany stru_junk(const_cast<Mod::JunkType_slice*>(stru.junk));
  Mod::MaskType_forany stru_mask(const_cast<Mod::MaskType_slice*>(stru.mask));
  gen_find_size(stru_junk, size, padding);
  gen_find_size(stru_mask, size, padding);
}

bool operator<<(Serializer& strm, const Mod::MaskedJunk& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Mod::JunkType_forany stru_junk(const_cast<Mod::JunkType_slice*>(stru.junk));
  Mod::MaskType_forany stru_mask(const_cast<Mod::MaskType_slice*>(stru.mask));
  return (strm << stru_junk)
    && (strm << stru_mask);
}

bool operator>>(Serializer& strm, Mod::MaskedJunk& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  Mod::JunkType_forany stru_junk(const_cast<Mod::JunkType_slice*>(stru.junk));
  Mod::MaskType_forany stru_mask(const_cast<Mod::MaskType_slice*>(stru.mask));
  return (strm >> stru_junk)
    && (strm >> stru_mask);
}

size_t gen_max_marshaled_size(const Mod::MaskedJunk& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

size_t gen_max_marshaled_size(KeyOnly<const Mod::MaskedJunk> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Mod::MaskedJunk> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Mod::MaskedJunk> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Mod::MaskedJunk> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Mod {
::DDS::DataWriter_ptr MaskedJunkTypeSupportImpl::create_datawriter()
{
  typedef OpenDDS::DCPS::DataWriterImpl_T<MaskedJunk> DataWriterImplType;
  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
  ACE_NEW_NORETURN(writer_impl,
                   DataWriterImplType());
  return writer_impl;
}

::DDS::DataReader_ptr MaskedJunkTypeSupportImpl::create_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MaskedJunk> DataReaderImplType;
  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(reader_impl,
                   DataReaderImplType());
  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr MaskedJunkTypeSupportImpl::create_multitopic_datareader()
{
  typedef OpenDDS::DCPS::DataReaderImpl_T<MaskedJunk> DataReaderImplType;
  typedef OpenDDS::DCPS::MultiTopicDataReader_T<MaskedJunk, DataReaderImplType> MultiTopicDataReaderImplType;
  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
  ACE_NEW_NORETURN(multitopic_reader_impl,
                   MultiTopicDataReaderImplType());
  return multitopic_reader_impl;
}
#endif /* !OPENDDS_NO_MULTI_TOPIC */

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
const OpenDDS::DCPS::MetaStruct& MaskedJunkTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<MaskedJunk>();
}
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */

bool MaskedJunkTypeSupportImpl::has_dcps_key()
{
  return TraitsType::gen_has_key ();
}

const char* MaskedJunkTypeSupportImpl::default_type_name() const
{
  return TraitsType::type_name();
}

MaskedJunkTypeSupport::_ptr_type MaskedJunkTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
{
  return TypeSupportType::_narrow(obj);
}
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Mod::MaskedJunk> : MetaStruct {
  typedef Mod::MaskedJunk T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const Mod::MaskedJunk& typed = *static_cast<const Mod::MaskedJunk*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MaskedJunk)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<Mod::JunkType_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<Mod::MaskType_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct Mod::MaskedJunk");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MaskedJunk)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"junk", "mask", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "junk") == 0) {
      return &static_cast<const T*>(stru)->junk;
    }
    if (std::strcmp(field, "mask") == 0) {
      return &static_cast<const T*>(stru)->mask;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MaskedJunk)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "junk") == 0) {
      Mod::JunkType* lhsArr = &static_cast<T*>(lhs)->junk;
      const Mod::JunkType* rhsArr = static_cast<const Mod::JunkType*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "mask") == 0) {
      Mod::MaskType* lhsArr = &static_cast<T*>(lhs)->mask;
      const Mod::MaskType* rhsArr = static_cast<const Mod::MaskType*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MaskedJunk)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct Mod::MaskedJunk)");
  }
};

template<>
const MetaStruct& getMetaStruct<Mod::MaskedJunk>()
{
  static MetaStructImpl<Mod::MaskedJunk> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, Mod::MaskedJunk*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<Mod::MaskedJunk>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

v8::Local<v8::Object> copyToV8(const Mod::MaskedJunk& src)
{
  ACE_UNUSED_ARG(src);
  const v8::Local<v8::Object> stru = Nan::New<v8::Object>();
  stru->Set(Nan::New<v8::String>("junk").ToLocalChecked(), copyToV8(src.junk));
  stru->Set(Nan::New<v8::String>("mask").ToLocalChecked(), copyToV8(src.mask));
  return stru;
}

void copyFromV8(const v8::Local<v8::Object>& src, Mod::MaskedJunk& out)
{
  ACE_UNUSED_ARG(src);
  ACE_UNUSED_ARG(out);
  {
    v8::Local<v8::String> field_str = Nan::New("junk").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.junk);
    }
  }
  {
    v8::Local<v8::String> field_str = Nan::New("mask").ToLocalChecked();
    if (src->Has(field_str)) {
      v8::Local<v8::Value> lv = src->Get(field_str);
      v8::Local<v8::Object> lo = Nan::To<v8::Object>(lv).ToLocalChecked();
      copyFromV8(lo, out.mask);
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace Mod {
class MaskedJunkTypeSupportV8Impl
  : public virtual MaskedJunkTypeSupportImpl
  , public virtual OpenDDS::DCPS::V8TypeConverter {

  v8::Local<v8::Object> toV8(const void* source) const
  {
    return OpenDDS::DCPS::copyToV8(*static_cast<const MaskedJunk*>(source));
  }

  void* fromV8(const v8::Local<v8::Object>& source) const
  {
    MaskedJunk* result = new MaskedJunk();
    OpenDDS::DCPS::copyFromV8(source, *result);
    return result;
  }

  void deleteFromV8Result(void* val) const
  {
    MaskedJunk* delete_me = static_cast< MaskedJunk*>(val);
    delete delete_me;
  }

  DDS::InstanceHandle_t register_instance_helper(DDS::DataWriter* dw, const void* data) const
  {
    MaskedJunkDataWriter* dw_t = dynamic_cast<MaskedJunkDataWriter*>(dw);
    return dw_t ? dw_t->register_instance(*static_cast<const MaskedJunk*>(data)) : DDS::HANDLE_NIL;
  }

  DDS::ReturnCode_t write_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    MaskedJunkDataWriter* dw_t = dynamic_cast<MaskedJunkDataWriter*>(dw);
    return dw_t ? dw_t->write(*static_cast<const MaskedJunk*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

  DDS::ReturnCode_t unregister_instance_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    MaskedJunkDataWriter* dw_t = dynamic_cast<MaskedJunkDataWriter*>(dw);
    return dw_t ? dw_t->unregister_instance(*static_cast<const MaskedJunk*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

  DDS::ReturnCode_t dispose_helper(DDS::DataWriter* dw, const void* data, DDS::InstanceHandle_t inst) const
  {
    MaskedJunkDataWriter* dw_t = dynamic_cast<MaskedJunkDataWriter*>(dw);
    return dw_t ? dw_t->dispose(*static_cast<const MaskedJunk*>(data), inst) : DDS::RETCODE_BAD_PARAMETER;
  }

public:
  struct Initializer {
    Initializer()
    {
      MaskedJunkTypeSupport_var ts = new MaskedJunkTypeSupportV8Impl;
      ts->register_type(0, "");
    }
  };
};

MaskedJunkTypeSupportV8Impl::Initializer init_tsv8_MaskedJunk;

}

/* End STRUCT: MaskedJunk */

/* End MODULE: Mod */
